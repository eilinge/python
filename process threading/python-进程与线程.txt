1.多任务:就是操作系统可以同时运行多个任务。
    并行：多个CPU核心,不同的程序就分配给不同的CPU来运行。可以让多个程序同时执行。
    并发：单个CPU核心,在一个时间切片里一次只能运行一个程序,如果需要运行多个程序,则串行执行。

    同步：当进程执行IO(等待外部数据）的时候，-----等。同步（例如打电话的时候必须等）
    异步：当进程执行IO(等待外部数据）的时候，-----不等，去执行其他任务，一直等到数据接收成功，再回来处理。异步（例如发短信）

2.进程,线程,协程
    1.概念
        进程: 对于操作系统来说，一个任务就是一个进程
        线程: 在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程
        协程: 微线程--在单线程上执行多个任务
    2.应用场景
        多进程：密集CPU任务,需要充分使用多核CPU资源(服务器,大量的并行计算)的时候,用多进程。multiprocessing
        缺陷：多个进程之间通信成本高,切换开销大。

        多线程：密集I/O任务（网络I/O,磁盘I/O,数据库I/O）使用多线程合适。threading
        缺陷：同一个时间切片只能运行一个线程,不能做到高并行,但是可以做到高并发。

        协程：又称微线程,在单线程上执行多个任务,用函数切换,开销极小。不通过操作系统调度,没有进程、线程的切换开销。
            多线程请求返回是无序的,那个线程有数据返回就处理那个线程,而协程返回的数据是有序的。
        缺陷：单线程执行,处理密集CPU和本地磁盘IO的时候,性能较低。处理网络I/O性能还是比较高.

3.进程与线程的比较
    1.相同点
        1.锁(url)
        2.共享资源(url)
        3.进/线程池,队列:Pool/Queue(只针对threading/multiprocess模块)
            1.进程:from multiprocess import Pool,Queue
            1.线程:Pool(自己实现)/Queue(import Queue)
    2.不同点
        1.实现进程与线程的模块
            multiprocessing/threading
        2.I/O密集型/计算密集型(url)
            在IO密集型任务中使用多线程，
                进行耗时的IO操作的时候，能释放GIL
            在计算密集型任务中使用多进程。
                调度多个CPU
        3.CPU利用率(url)
            进程:调用多个CPU
            线程:一个CPU调用多个线程,多线程之间切换
        4.功能
            进程:调用多个CPU,能够完成多任务,比如 在一台电脑上能够同时运行多个QQ()
            线程:一个CPU调用多个线程,多线程之间切换,能够完成多任务,比如 一个QQ中的多个聊天窗口
        5.定义
            进程是操作系统分配资源的最小单元, 线程是操作系统调度的最小单元。
            一个应用程序至少包括1个进程,而1个进程包括1个或多个线程,线程的尺度更小。
            每个进程在执行           过程中拥有独立的内存单元,而一个进程的多个线程在执行过程中共享内存。
        6.优缺点
            线程执行开销小,但不利于资源的管理和保护；而进程正相反。


锁:
线/进程锁类，分别是：
    Lock 互斥锁:同一时刻只有一个线程可以访问共享的数据。
    RLock 可重入锁:在同一个线程中，RLock.acquire()可以被多次调用
      当所有RLock被release后，其他线程才能获取资源。
    Semaphore 信号:这种锁允许一定数量的线程同时更改数据，它不是互斥锁。
    Event 事件:set()、wait()、clear()和is_set()。
      调用clear()方法会将事件的Flag设置为False。
      调用set()方法会将Flag设置为True。
      调用wait()方法将等待信号。
      is_set():判断当前状态
    Condition 条件
      wait([timeout])方法将使线程进入Condition的等待池等待通知，并释放锁。
        使用前线程必须已获得锁定，否则将抛出异常。
      notify()方法将从等待池挑选一个线程并通知，收到通知的线程将自动调用acquire()尝试获得锁定

锁(多线程)的由来:
    多线程编程,模型复杂,容易发生冲突,必须用锁加以隔离,同时,又要小心死锁的发生。
    Python解释器由于设计时有GIL全局锁,导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。

    在一个进程内的所有线程共享全局变量,很方便在多个线程间共享数据
    缺点就是,线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）
    如果多个线程同时对同一个全局变量操作,会出现资源竞争问题,从而数据结果会不正确(线程同步(lock))

锁的应用:
    当多个线程几乎同时修改某一个共享数据的时候,需要进行同步控制
    线程同步能够保证多个线程安全访问竞争资源,最简单的同步机制是引入互斥锁。
        互斥锁为资源引入一个状态：锁定/非锁定

运行原理:
    某个线程要更改共享数据时,先将其锁定,此时资源的状态为“锁定”,其他线程不能更改；
    直到该线程释放资源,将资源的状态变成“非锁定”,其他的线程才能再次锁定该资源。
    互斥锁保证了每次只有一个线程进行写入操作,从而保证了多线程情况下数据的正确性。

注意:
    如果这个锁之前是没有上锁的,那么acquire不会堵塞
    如果在调用acquire对这个锁上锁之前,它已经被其他线程上了锁,那么此时acquire会堵塞,直到这个锁被解锁为止

锁的好处：
    确保了某段关键代码只能由一个线程从头到尾完整地执行
锁的坏处：
    阻止了多线程并发执行,包含锁的某段代码实际上只能以单线程模式执行,效率就大大地下降了
    由于可以存在多个锁,不同的线程持有不同的锁,并试图获取对方持有的锁时,可能会造成死锁
    死锁:在线程间共享多个资源的时候,如果两个线程分别占有一部分资源并且同时等待对方的资源,就会造成死锁。

问题1: 什么时候会释放Gil锁?
    1 遇到像 i/o操作这种 会有时间空闲情况 造成cpu闲置的情况会释放Gil
    2 会有一个专门ticks进行计数 一旦ticks数值达到100 这个时候释放Gil锁 线程之间开始竞争Gil锁(说明:
        ticks这个数值可以进行设置来延长或者缩减获得Gil锁的线程使用cpu的时间)

问题2: 互斥锁和Gil锁的关系?
    Gil锁 : 保证同一时刻只有一个线程能使用到cpu
    互斥锁 : 多线程时,保证修改共享数据时有序的修改,不会产生数据修改混乱

首先假设只有一个进程,这个进程中有两个线程 Thread1,Thread2, 要修改共享的数据date, 并且有互斥锁?

执行以下步骤
    (1)多线程运行,假设Thread1获得GIL可以使用cpu,这时Thread1获得 互斥锁lock,Thread1可以改date数据(但并
    没有开始修改数据)
    (2)Thread1线程在修改date数据前发生了 i/o操作 或者 ticks计数满100 (注意就是没有运行到修改data数据),这个
    时候 Thread1 让出了Gil,Gil锁可以被竞争
    (3) Thread1 和 Thread2 开始竞争 Gil (注意:如果Thread1是因为 i/o 阻塞 让出的Gil Thread2必定拿到Gil,如果
    Thread1是因为ticks计数满100让出Gil 这个时候 Thread1 和 Thread2 公平竞争)
    (4)假设 Thread2正好获得了GIL, 运行代码去修改共享数据date,由于Thread1有互斥锁lock,所以Thread2无法更改共享数据
    date,这时Thread2让出Gil锁 , GIL锁再次发生竞争 
    (5)假设Thread1又抢到GIL,由于其有互斥锁Lock所以其可以继续修改共享数据data,当Thread1修改完数据释放互斥锁lock,
    Thread2在获得GIL与lock后才可对data进行修改


Pool
    对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，
    调用close()之后就不能继续添加新的Process了。

    请注意输出的结果，task 0，1，2，3是立刻执行的，而task 4要等待前面某个
    task完成后才执行，这是因为Pool的默认大小在我的电脑上是4，因此，最多同时执行4个进程。
    Pool的默认大小是CPU的核数